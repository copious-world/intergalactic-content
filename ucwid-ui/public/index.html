<!doctype html>
<html>
<head>
	

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="author" content="$AUTHOR" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
<meta id="theme-color" name="theme-color" content="#452770">

<link rel="canonical" href="http://www.copious.world">

<title>Copious World</title>
<meta name="description" content="An entry point into the our world of AI, IoT, and Communities built around songs, etc.">


	
	<link rel='icon' type='image/png' href='./favicon.png'>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,600,700" />
	<link rel='stylesheet' href='./global.css'>
	<link rel='stylesheet' href='./build/bundle.css'>

	<script defer src='./build/bundle.js'></script>
</head>
<style>

/*csslint important:false*/

body {
	height: 100%;
}

/**
* Always hide an element when it has the `hidden` HTML attribute.
*/

.hidden,
[hidden] {
	display: none !important;
}

/**
* Add this class to an image to make it fit within it's fluid parent wrapper while maintaining
* aspect ratio.
*/
.pure-img {
	max-width: 100%;
	height: auto;
	display: block;
}


.fitMenuLower {
	width: 95%;
	height: 50%;
	margin-left:0px;
	margin-right:0px;
	padding: 8px;
	margin-top:8px;
	background: -webkit-linear-gradient(to right, white, #FAFAFF);
	background: linear-gradient(to right, white, #FAFAFF );
	margin-left: 10px;
}

#squashMenu:hover {
	border: 1px solid rgb(230,230,240,0.4);
	padding-top:4px;
	background-color: #EFEFEF;
}

#squashMenuContainer {
	position:absolute;
	visibility:hidden;
	top : 0; left : 0;
	height:100%;
	width: 55%;
	z-index:100;
	border: rgba(252, 190, 190, 0.4) 2px solid;
	background-color: white;
}

#thankyou_box {
	position:absolute;
	visibility:hidden;
	top : 25%; left : 25%;
	height:50%;
	width: 50%;
	z-index:150;
	border: rgba(100, 5, 5, 0.6) 2px solid;
	background-color: lightgoldenrodyellow;
	overflow: auto;
}

button {
	cursor: pointer;
	font-size: 101%;
	font-weight: bold;
	color: darkblue;
	margin: 2px;
	width:120px;
}

button:hover {
	background-color : #CACAFF;
	color: darkred;
}


body {
	border: 1px solid black;
	
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}


@media screen and (orientation: portrait) {
	#mainNav {
		width: 100%;
	}
}

@media screen and (orientation: landscape) {
	#mainNav {
		width: 100%;
	}
}

main {
	border-left: solid 3px navy;
	border-top: solid 1px #8833BB;
	padding : 4px;
}

#mainNav {
	font-family: 'Montserrat', 'Helvetica Neue', Helvetica, Arial, sans-serif;
	font-weight: 700;
	text-transform: uppercase;
	background: blue;
	border-left: solid 3px navy;
	border-top: solid 3px navy;
	border-bottom: solid 3px rgba(252,252,255,0.7);
	min-height: 90px;
	padding: 20px;
	background: -webkit-linear-gradient(to left, rgba(242, 242, 210, 0.3), white);
	background: linear-gradient(to left, rgba(242, 242, 210, 0.3), white );
	
}

#mainNav table {
	padding-left: 3%;
}

#mainNav  table  a:focus { outline: none; }
#mainNav  table  .navbar-brand {
	font-size: 1.1rem;
	color: white;
}

#mainNav  table  .navbar-brand.active, #mainNav .navbar-brand:active, #mainNav .navbar-brand:focus, #mainNav .navbar-brand:hover {
	color: white;
}

#mainNav  table  .navbar-nav {
	letter-spacing: 1px; }

#mainNav  table  .navbar-nav li.nav-item {
	display:inline;
}

#mainNav  table  .navbar-nav li.nav-item a.nav-link {
	color: darkgreen;
	text-decoration: none;
	vertical-align: top;
	padding-right: 10px;
}

#mainNav  table  .navbar-nav li.nav-item a.nav-link:hover {
	color: #18BC9C;
	outline: none;
	
}

#mainNav  table  .navbar-nav a.nav-text {
	background-color : rgba(242,222,255,0.6);
	border-radius: 25px;
	margin-bottom: 9px;
	margin-right: 6px;
	white-space: nowrap;
}

#mainNav  table  .navbar-nav li.nav-item a.nav-link:active, #mainNav .navbar-nav li.nav-item a.nav-link:focus { color: white; }

.footer-list li {
	list-style-type: none;
}

.footer-list li a:hover { color: gold; }

footer {
	padding:10px;
	background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2 );
	background: linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2  );
	text-align: center;
	font-size: 0.85em;
}

footer a {
	text-decoration:none;
	color:darkgreen;
	font-weight:bold;
	font-style: italic;
}

.copiouslink:hover {
	fill:navy;
}
.copiouslink {
	fill:black;
}

* {margin: 0; padding: 0; box-sizing: border-box}

.PhIOtjDr_0 {
	fill:none;
	stroke:#1c1448;
	stroke-width:4.59875107;
	stroke-miterlimit:4;
	stroke-dasharray: 2948 2950;
	stroke-dashoffset: 2949;
	animation: PhIOtjDr_draw 6666ms ease-in forwards;
}

@keyframes PhIOtjDr_draw {
	100% {stroke-dashoffset: 0}
}

@keyframes PhIOtjDr_fade {
	0% {stroke-opacity: 1}
	97.1830985915493% {stroke-opacity: 1}
	100% {stroke-opacity: 0}
}

label {
	font-weight:bold;
	color:darkgreen;
	width:35%;
}

.error-message {
	visibility:hidden;
	width:75%;
	font-weight:bolder;
	color:red;
	background-color:white;
	border: solid 1px orange;
	padding:2px;
	margin:3px;
}

/* The Close Button */
.close {
	color: white;
	float: right;
	font-size: 18px;
	font-weight: bold;
}

.close:hover,
.close:focus {
	color: #000;
	text-decoration: none;
	cursor: pointer;
}

/* Add Animation */
@-webkit-keyframes slideIn {
	from {bottom: -300px; opacity: 0}
	to {bottom: 0; opacity: 1}
}

@keyframes slideIn {
	from {bottom: -300px; opacity: 0}
	to {top: 0; opacity: 1}
}

@-webkit-keyframes fadeIn {
	from {opacity: 0}
	to {opacity: 1}
}

@keyframes fadeIn {
	from {opacity: 0}
	to {opacity: 1}
}

.no-view-file-field {
	display: none;
	visibility: hidden;
}

h2 {
	text-transform: capitalize;
	color:#4ca85c;
	font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
}


#active-user-title {
	font-size: 95%;
	font-style: oblique;
	font-weight: bold;
	margin: 2%;
	color: goldenrod;
}
</style>
<script>
	var g_siteURL = window.location.host;
	var g_finalizers = []
	var g_loginStateViewHolders = {}
</script>
<body>

<nav id="mainNav">
	<table style="width:100%">
		<tr>
			<td style="width:62;height:63">
				<a class="nav-link" href="/"  target="http://www.copious.world-again" >
											    <svg version="1.0" width="60" height="60" viewBox="0 0 250 250" preserveAspectRatio="xMidYMid meet" id="logo" >
								<defs id="defs10"/>
								<path class="PhIOtjDr_0"  id="path6" d="m 30.107062,7.4672872 c 4.67725,2.6985208 8.37554,8.6930958 12.94402,20.5087688 7.17904,19.072767 24.58277,67.337762 29.69511,82.950634 l 5.32989,15.9502 -13.70543,-0.25058 -10.468161,2.57106 -8.132079,2.99946 -4.78602,5.90784 0.76141,-6.91979 c 0.65264,-6.50536 0.32632,-7.85462 -5.43866,-25.31791 C 27.822822,80.549048 20.535012,60.127019 12.703332,40.215781 5.4155222,21.730904 4.4365622,15.57249 7.8085322,10.503124 11.941922,4.43145 22.384152,2.9954505 30.107062,7.4672872 Z M 238.08162,22.742849 c 3.69828,2.110631 6.52639,6.669206 6.52639,10.379672 0,1.686578 -2.93688,12.740881 -6.63517,24.469814 -19.68797,64.138095 -30.34775,107.931245 -30.34775,124.806655 0,4.6453 -1.08775,7.68113 -18.60024,50.80931 l -4.35093,10.79409 -67.76577,0 -67.765758,0 -14.35808,-35.35063 -14.35808,-35.3603 17.62128,-20.75934 17.5125,-20.75935 29.36879,0 c 32.631998,0 5.455822,5.28877 29.390108,7.16797 -3.81133,6.98972 7.16732,11.29772 7.16732,11.29772 l 2.51778,3.43975 c -1.74038,3.20932 -4.92039,6.69891 -9.3801,9.5709 l -3.2632,2.11064 -9.78959,-2.62144 c -8.593088,-2.27446 -11.312428,-2.61179 -22.080978,-2.61179 -13.0528,-0.0964 -14.35808,0.2506 -14.35808,4.29837 0,2.70817 3.15443,3.63336 12.72648,3.63336 21.42834,0 38.723308,8.01847 47.533928,22.10863 3.58951,5.73436 7.17904,15.86345 7.17904,20.50876 0,2.86236 4.45971,5.05973 7.50536,3.79721 2.82811,-1.09868 2.93687,-4.64531 0.65264,-14.01306 -2.28424,-9.36772 -7.83169,-17.88734 -15.77214,-24.29632 -5.32988,-4.30799 -6.30884,-5.49342 -5.11233,-6.24517 1.19649,-0.76135 2.06669,-0.51077 4.0246,1.08906 6.30885,5.23321 19.03534,7.00654 27.73719,3.88395 5.87377,-2.11064 11.85631,-7.17036 15.11951,-12.74088 1.52281,-2.53468 5.98253,-16.03694 9.89835,-29.9536 10.98611,-38.396111 22.08098,-72.320389 30.13021,-92.665317 5.54744,-14.176879 12.40016,-19.737762 23.16871,-18.812555 2.93688,0.250577 6.63517,1.175785 8.15801,2.023891 z m -126.72091,50.03831 c 2.28424,0.510792 5.76499,2.11063 7.72291,3.633367 5.87375,4.558576 6.20008,7.257098 3.80705,29.278954 -1.1965,10.71701 -1.94404,26.93071 -2.27035,27.1042 -0.32632,0.25057 -8.38942,-6.50868 -17.41761,-6.25812 l -16.533538,0.42407 0.65264,-6.66922 c 0.32632,-3.62372 1.19651,-13.83956 1.84915,-22.619385 0.65264,-9.19425 1.74037,-17.125977 2.50179,-18.561977 3.2632,-5.907835 10.550998,-8.269041 19.687958,-6.331889 z m 48.5129,9.454465 c 2.06668,1.011946 4.56848,3.209314 5.54744,4.89589 1.84914,2.871998 1.84914,4.22126 -0.8702,33.750816 -1.52282,17.04886 -3.37196,32.575 -4.24216,35.02295 -3.15442,8.51961 -9.13695,13.07819 -18.16513,13.67573 -4.78601,0.25056 -6.41762,0 -9.46327,-1.69622 -5.87376,-3.12256 -6.41764,-4.29838 -2.93689,-7.42094 6.20008,-5.744 4.00097,-11.09854 1.92352,-15.89687 0,0 -0.33391,-1.79223 -2.65798,-4.24016 l -2.01123,-1.92782 3.94219,-26.79768 c 1.95792,-22.869967 2.17547,-23.795174 5.11237,-26.667174 4.89478,-4.89589 16.96861,-6.24515 23.82134,-2.698522 z" />
								<rect style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:4.80000019;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4169" width="68.005806" height="55.413109" x="62.964886" y="157.3824"/>
								<rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1.60000002;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4170" width="39.957146" height="46.691494" x="105.05587" y="172.33051"/>
								<rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4172" width="134.35677" height="7.9790406" x="49.16119" y="238.93228"/>
								<text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:184.28874207px;line-height:125%;font-family:'Arial Rounded MT Bold';-inkscape-font-specification:'Arial Rounded MT Bold, Normal';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#0000ff;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="6.6644416" y="260.41125" id="text4161" transform="scale(1.041834,0.95984582)"><tspan id="tspan4163" x="6.6644416" y="260.41125">C</tspan></text>
								<text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:28.53204727px;line-height:125%;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ff0000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="90" y="175.07523" id="text4165" transform="scale(0.90874022,1.1004245)"><tspan id="tspan4167" x="90" y="175.07523">opious</tspan></text>
							</svg>

				</a>
			</td>
			<td>
				<ul class="navbar-nav">
					<li class="nav-item">
						<a class="nav-link" href="https://github.com/copious-world" target="GitGHub" >
							<svg role="img" width="30" height="30"  preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<title>GitHub copious-world</title>
<path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
</svg>

						</a>
					</li>
					<li id="squashMenu"   class="nav-item" style="visibility:hidden;cursor:pointer" onmousedown="menuHandler(this)" onmouseup="releaseMenu(this)">
						$file::mushroom-menu-icon.svg<<
					</li>
				</ul>
			</td>
			<td style="text-align: center;">
				<h2></h2> 
				<span id="active-user-title">ucwid</span>  :: ----
			</td>
			<td>
				&nbsp;
			</td>
		</tr>
	</table>
</nav>

	<main id='app-main'>
	
	</main>
	<div style="visibility: hidden;">
		<a id='identity-download-link' href = "" >identity download</a>
		<input class="no-view-file-field" type="file" id="drop-click-file_loader" />
	</div>

<footer>
	<ul class="footer-list">
		<li>
			<a href="http://www.copious.world" target="http://www.copious.world-again">copyright &copy; 2020 copious.world</a>
			<span class="status-style" id="page-error-message">status: good</span>
		</li>
	</ul>
</footer>

</body>
</html>
<script>

// ---- ---- ---- ---- ---- ----  ---- ---- ---- ---- ---- ----  ---- ---- ---- ---- ---- ----  ---- ---- ---- ---- ---- ----


// MODULE: PC LOCATION (windowized)



//$>>	pc_getLocation

function pc_getLocation() {
    if (navigator.geolocation) {
      let loc_display = document.getElementById("wv-geo-location");
      navigator.geolocation.watchPosition((position) => {  // watch position updates location at a system defined interval
        if ( loc_display ) loc_display.innerHTML = `${position.coords.latitude},${position.coords.longitude}`
        g_pc_current_locaion = { "latitude" : position.coords.latitude, "longitude" : position.coords.longitude }  // clone
        pc_update_geo_location(g_pc_current_locaion)
      });
    } else { 
      alert("Geolocation is not supported by this browser.");
    }
  }
  
  



//$EXPORTABLE::
/*
pc_getLocation
*/


// MODULE: common (windowized)


//$>>	ext_of_file
function ext_of_file(file_name) {
	let idx = file_name.lastIndexOf('.')
	let ext = file_name.substr(idx+1)
	return ext
}

//$>>	clonify
function clonify(obj) {
	if ( typeof obj === 'string' ) return(obj)
	try {
		let out = JSON.parse(JSON.stringify(obj))
		return(out)
	} catch(e) {
		return(null)
	}
}

//$>>	launch_simple_link
//
function normalized_launch_url(default_url) {
	let uri_of_launch = ""
	if ( default_url.indexOf('http://') === 0 ) {
		uri_of_launch = default_url
	} else {
		uri_of_launch = `https://${default_url}/`
	}
	return uri_of_launch
}

//                                                  <<depends>> errorMessage, normalized_launch_url
function launch_simple_link(default_url,window_name) {
	let uri_of_launch = normalized_launch_url(default_url)
	let launched = window.open(uri_of_launch,window_name)
	//
	if ( !launched ) {
		errorMessage(`could not open window or tab for link ${uri_of_launch}`)
	}
	return [launched,uri_of_launch]
}




// MODULE: HTTPS CHECKS (windowized)

//$>>	not_https_switch
// switch to HTTPS before doing any ops that may require a data exchange
function not_https_switch() {
	if (location.protocol !== 'https:') {           // start from a secure page
		alert("Switching to a secure version of this page in 1sec.")
		setTimeout(()=> {location.replace(`https:${location.href.substring(location.protocol.length)}`)},1000)
		return(true)
	}
	return(false)
}


//$>>	getCookie
// simple check on cookies, searching by ';' delimited string with the cookie name at the start of the trimmed line.
function getCookie(cname) {  // modified from w3school
	var name = cname + "=";
	var ca = document.cookie.split(';');
	for(let i = 0; i < ca.length; i++) {
		var c = ca[i];
		if ( typeof c === 'string' ) {
			c = c.trim()
			if (c.indexOf(name) == 0) {
				return c.substring(name.length);
			}
		}
	}
	return "";
}



//$EXPORTABLE::
/*
not_https_switch
getCookie
*/



// MODULE: POST FETCH (windowized)

//$>>	postData
// //
//  call fetch with method POST tyr to help with parameters..  If data is FromData set do_stringify to false
//  default content type 'application/json'
//  User 'cors', Default cres = omit, If ctype == 'multipart/form-data' be sure to use FormData -- lets fetch set content type.
//  RETURNS: parsed JSON object or an empty object. ... Check for fields
//
async function postData(url = '', data = {}, creds = 'omit', do_stringify = true,ctype) {
	let content_type = 'application/json'
	if ( ctype !== undefined ) {
		content_type = ctype            // ctype is content type
	}
	let options = {
		method: 'POST', // *GET, POST, PUT, DELETE, etc.
		mode: 'cors', // no-cors, *cors, same-origin
		cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
		credentials: creds, // include, *same-origin, omit
		headers: {
			'Content-Type': content_type
		},
		redirect: 'follow', // manual, *follow, error
		referrerPolicy: 'no-referrer', // no-referrer, *client
		body: (do_stringify ? JSON.stringify(data)  : data)	// body data type must match "Content-Type" header
	}

	if ( ctype === 'multipart/form-data') {
		delete options.headers['Content-Type']  // content type will be set automatically with a boundary
	}

	// Default options are marked with *
	const response = await fetch(url, options);
	if ( response.ok == false ) {
		console.log(response.status + ': ' + response.statusText)
		return {}
	} else {
		return await response.json(); // parses JSON response into native JavaScript objects
	}
}




// ---- ---- ---- ---- ---- 



// MODULE: GLOBAL CRYPTO (windowized)

//$>>	setup_window_crypto
function setup_window_crypto() {
  if ( window.g_crypto === undefined ) {
    window.g_crypto = window.crypto ? window.crypto.subtle : null
    if ( g_crypto === null  ) {
      alert("No cryptography support in this browser. To claim ownership of assets, please use another browser.")
    }
  }
}

//$EXPORTABLE::
/*
setup_window_crypto
*/


// MODULE: base64 (windowized)
/*
MIT License

Copyright (c) 2020 Egor Nepomnyaschih

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

//$>>	getBase64Code
/*
// This constant can also be computed with the following algorithm:
const base64abc = [],
	A = "A".charCodeAt(0),
	a = "a".charCodeAt(0),
	n = "0".charCodeAt(0);
for (let i = 0; i < 26; ++i) {
	base64abc.push(String.fromCharCode(A + i));
}
for (let i = 0; i < 26; ++i) {
	base64abc.push(String.fromCharCode(a + i));
}
for (let i = 0; i < 10; ++i) {
	base64abc.push(String.fromCharCode(n + i));
}
base64abc.push("+");
base64abc.push("/");
*/
const base64abc = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"
];

const base64abc_url = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "_"
]

/*
// This constant can also be computed with the following algorithm:
const l = 256, base64codes = new Uint8Array(l);
for (let i = 0; i < l; ++i) {
	base64codes[i] = 255; // invalid character
}
base64abc.forEach((char, index) => {
	base64codes[char.charCodeAt(0)] = index;
});
base64codes["=".charCodeAt(0)] = 0; // ignored anyway, so we just need to prevent an error
*/
const base64codes = [
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255,
	255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
	15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255,
	255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
];

const url_alternates = "-_"
const plus_alt = url_alternates.charCodeAt(0)
const slash_alt = url_alternates.charCodeAt(1)

function getBase64Code(charCode) {
	if ( plus_alt === charCode ) {
		return 62
	}
	if ( slash_alt === charCode ) {
		return 63
	}
	if (charCode >= base64codes.length) {
		throw new Error("Unable to parse base64 string.");
	}
	const code = base64codes[charCode];
	if (code === 255) {
		throw new Error("Unable to parse base64 string.");
	}
	return code;
}

//$>>	bytesToBase64
function bytesToBase64(bytes,url_no) {
	let apha = url_no ? base64abc : base64abc_url
	let result = '', i, l = bytes.length;
	for (i = 2; i < l; i += 3) {
		result += apha[bytes[i - 2] >> 2];
		result += apha[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += apha[((bytes[i - 1] & 0x0F) << 2) | (bytes[i] >> 6)];
		result += apha[bytes[i] & 0x3F];
	}
	if (i === l + 1) { // 1 octet yet to write
		result += apha[bytes[i - 2] >> 2];
		result += apha[(bytes[i - 2] & 0x03) << 4];
		result += "==";
	}
	if (i === l) { // 2 octets yet to write
		result += apha[bytes[i - 2] >> 2];
		result += apha[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += apha[(bytes[i - 1] & 0x0F) << 2];
		result += "=";
	}
	return result;
}

//$>>	base64ToBytes
function base64ToBytes(str) {
	if (str.length % 4 !== 0) {
		throw new Error("Unable to parse base64 string.");
	}
	const index = str.indexOf("=");
	if (index !== -1 && index < str.length - 2) {
		throw new Error("Unable to parse base64 string.");
	}
	let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0,
		n = str.length,
		result = new Uint8Array(3 * (n / 4)),
		buffer;
	for (let i = 0, j = 0; i < n; i += 4, j += 3) {
		buffer =
			getBase64Code(str.charCodeAt(i)) << 18 |
			getBase64Code(str.charCodeAt(i + 1)) << 12 |
			getBase64Code(str.charCodeAt(i + 2)) << 6 |
			getBase64Code(str.charCodeAt(i + 3));
		result[j] = buffer >> 16;
		result[j + 1] = (buffer >> 8) & 0xFF;
		result[j + 2] = buffer & 0xFF;
	}
	return result.subarray(0, result.length - missingOctets);
}


//$>>	base64encode
function base64encode(str, encoder = new TextEncoder()) {
	return bytesToBase64(encoder.encode(str));
}

//$>>	base64decode
function base64decode(str, decoder = new TextDecoder()) {
	return decoder.decode(base64ToBytes(str));
}



//$EXPORTABLE::
/*
getBase64Code
bytesToBase64
base64ToBytes
base64encode
base64decode
*/


// MODULE: BASE STRING (windowized)


let base_string = window

//$>>	gen_nonce
function gen_nonce() {
	return btoa(window.crypto.getRandomValues(new Uint8Array(16)))
}


//$>>	hex_fromArrayOfBytes
//>--
function hex_fromArrayOfBytes(arrayOfBytes) {
    const hexstr = arrayOfBytes.map(b => b.toString(16).padStart(2, '0')).join('');
    return(hexstr)
}
//--<

//$>>	hex_fromTypedArray
//                                                  <<depends>> hex_fromArrayOfBytes
//>--
function hex_fromTypedArray(byteArray){
    let arrayOfBytes = Array.from(byteArray)
    return(hex_fromArrayOfBytes(arrayOfBytes))
}
//--<

//$>>	hex_fromByteArray
//                                                  <<depends>> hex_fromTypedArray,ArrayOfBytes_toByteArray
//>--
function hex_fromByteArray(byteArray){
    return hex_fromTypedArray(ArrayOfBytes_toByteArray(byteArray))
}
//--<

//$>>	hex_toArrayOfBytes
//>--
function hex_toArrayOfBytes(hexString) {
    let result = [];
    for ( let i = 0; i < hexString.length; i += 2 ) {
      result.push(parseInt(hexString.substr(i, 2), 16));
    }
    return result;
}
//--<


//$>>	ArrayOfBytes_toByteArray
//>--
function ArrayOfBytes_toByteArray(arrayOfBytes) {
    let byteArray = new Uint8Array(arrayOfBytes)
    return(byteArray)
}
//--<



//$>>	hex_toByteArray
//                                                  <<depends>> hex_toArrayOfBytes
//>--
function hex_toByteArray(hexstr) {
    let aob = hex_toArrayOfBytes(hexstr)
    return ArrayOfBytes_toByteArray(aob)
}
//--<

//$>>	bufferToArrayBufferCycle
//>--
function bufferToArrayBufferCycle(buffer) {
  var ab = new ArrayBuffer(buffer.length);
  var view = new Uint8Array(ab);
  for (var i = 0; i < buffer.length; ++i) {
      view[i] = buffer[i];
  }
  return ab;
}
//--<

//$>>	string_from_buffer
//>--
function string_from_buffer(bytes) {
	let s = ""
	let n = bytes.length
	for ( let i = 0; i < n; i++ ) {
		let c_code = bytes[i]
		s += String.fromCharCode(c_code)
	}
	return s
}
//--<


//$>>	buffer_from_cvs_array
//>--
function buffer_from_cvs_array(number_els) {
	let els = number_els.split(',').map(el => parseInt(el))
	let buf = new Uint8Array(els)
	return buf
}
//--<

//$>>	buffer_from_b64_csv
//                                                  <<depends>> buffer_from_cvs_array
//>--
function buffer_from_b64_csv(b64_number_els) {
	let numbers = atob(b64_number_els)
	return buffer_from_cvs_array(numbers)
}
//--<

//$EXPORTABLE::
/*
gen_nonce
hex_fromArrayOfBytes
hex_fromTypedArray
hex_fromByteArray
hex_toArrayOfBytes
ArrayOfBytes_toByteArray
hex_toByteArray
bufferToArrayBufferCycle
string_from_buffer
buffer_from_cvs_array
buffer_from_b64_csv
*/



// MODULE: CRYPTO HASH (windowized)

// >> import
//modularize>> import * as base64 from "../modules/base64.js";
//<<
base64 = window

//$>>	do_hash_buffer
async function do_hash_buffer(text) {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hash = await g_crypto.digest('SHA-256', data);
    return hash
}

//$>>	do_hash
async function do_hash(text) {
    let buffer = await do_hash_buffer(text)
    const hashArray = Array.from(new Uint8Array(buffer));
    return base64.bytesToBase64(hashArray)
}

//$>>	from_hash
function from_hash(base64text) {
    let bytes = base64.base64ToBytes(base64text)
    return bytes
}

//$>>	to_base64
function to_base64(text) {
    return base64.base64encode(text)
}

//$>>	from_base64
function from_base64(base64text) {
    let bytesAsText = base64.base64decode(base64text)
    return bytesAsText
}

//$>>	from_base64_to_uint8array
function from_base64_to_uint8array(base64text) {
    while ( base64text.length %4 ) base64text += '='
    return base64.base64ToBytes(base64text)
}

//$>>	to_base64_from_uint8array
function to_base64_from_uint8array(a_uint8Array) {
    let b = base64.bytesToBase64(a_uint8Array)
    b = b.replace(/\=/g,'')
    return b
}

//$EXPORTABLE::
/*
do_hash_buffer
do_hash
from_hash
to_base64
from_base64
from_base64_to_uint8array
to_base64_from_uint8array
*/



// MODULE: CRYPTO WRAPS (windowized)

// sometimes code doesn't want to be a module. But, there is a module version of this in npm crypto-wraps
//

// ---- ---- ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ---- ---- ----

let cwraps = window 

//$>>	gen_nonce
/*
// gen_nonce
// Parameters: optional parameter
// 	--	no parameter case
// 	--	generate a random vaue -- return it as string
// 	--	parameter (optional) : A base64url string that is at least 16 bytes
//		-- returns the the first bytes as a base64url string (for deriving an IV from data) Not random
// 
// Returns a nonce as a base64url string representing 16 bytes = 128 bits
*/
function gen_nonce(input_bits) {
	if ( input_bits === undefined ) {
		let random = window.crypto.getRandomValues(new Uint8Array(16))
		return to_base64_from_uint8array(random)
	} else {
		let bytes = from_base64_to_uint8array(input_bits)
		bytes = bytes.subarray(0, 16)
		return to_base64_from_uint8array(bytes)
	}
}

//$>>	gen_cipher_key
/*
// gen_cipher_key
//    -- generates an AES key "AES-CBC",256 for encrypting and decrypting
// Returns: aes_key as a CryptoKey structure (see crypto.subtle.generateKey)
*/
async function gen_cipher_key() {
	//
	try {
		let aes_key = g_crypto.generateKey({
												name: "AES-CBC",
												length: 256
											},
											true,
											["encrypt", "decrypt"]
										)	

		return aes_key
	} catch(e){}
	//
	return false
}


//$>>	pc_keypair_promise
//>--
// pc_keypair_promise
// Parameters: no parameters
// Returns: a Promise that resolves to an elliptic curve key using P-384 with sign and verify privileges
//  -- 
function pc_keypair_promise() {  // return 
    // Generate a local public/private key pair
    let p =  g_crypto.generateKey({
            'name': "ECDSA",
            'namedCurve': "P-384"
        },
        true,
        ["sign", "verify"]
    )
    return p  // promise
}
//-


//$>>	axiom_keypair_promise
//>--
// axiom_keypair_promise
// Parameters: no parameters
// Returns: a Promise that resolve to an elliptic curve key using P-384 with cipher key derivation privileges. Allows for deriving AES 256 cipher key
//  -- 
function axiom_keypair_promise() {
    // Generate a local public/private key pair
    let p =  g_crypto.generateKey({
            'name': "ECDH",
            'namedCurve': "P-384"
        },
        true,
        ["deriveKey"]
    )
    return p  // promise
}


//$>>	pc_wrapper_keypair_promise
//>--
// pc_wrapper_keypair_promise
// Parameters: no parameters
// Returns: a Promise that resolves to an RSA-OAEP key modulus 4096 hash to SHA-256 with wrapKey and unwrapKey privileges
//  -- 
function pc_wrapper_keypair_promise() {  // return 
    // Generate a local public/private key pair
    let p =  g_crypto.generateKey({
            name: "RSA-OAEP",
            modulusLength: 4096, //can be 1024, 2048, or 4096
            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
            hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
        },
        true,
        ["wrapKey","unwrapKey"]
    )
    return p  // promise
}
//--<


//$>>	aes_encryptor
/*
// aes_encryptor
// Parameters:  
//        		encodable -  a string
//   			aes_key - aes_key as CryptoKey
//				nonce - random (gen_nonce) passed as a uint8Array
// Returns: The enciphered text ArrayBuffer
*/
async function aes_encryptor(encodable,aes_key,nonce) {

	let enc = new TextEncoder();
	let clear_buf =  enc.encode(encodable);
	let iv = nonce

    let ciphertext = await g_crypto.encrypt({
												name: "AES-CBC",
												iv
											},
											aes_key,
											clear_buf
										);
	return ciphertext
}


//$>>	aes_decipher_message
/*
// aes_decipher_message
// Parameters:  
//  			message -  as a uint8Array
//				aes_key - aes key as CryptoKey
//				nonce - random (gen_nonce) passed as a uint8Array
// Returns: clear text
*/
async function aes_decipher_message(message,aes_key,nonce) {
	let iv = nonce
    let decrypted = await g_crypto.decrypt({
												name: "AES-CBC",
												iv
											},
											aes_key,
											message
										);
	//
	let dec = new TextDecoder()
	let clear = dec.decode(decrypted)
	return clear
}
//
// 


//$>>	galactic_user_starter_keys
/*
// galactic_user_starter_keys
// Parameters: no parameters or (optional) a selector parameter
// 
// Optional parameters values:  "wrapper", "signer"  
//								Purpose:  produce only the selected key pair
//    make a priv/pub key pair.
// Return: an object containing all key pairs
//
	let key_info = {
		"pk_str" : pub_key_str,
		"priv_key" : priv_key_str,
		"signer_pk_str"  : sign_pub_key_str,
		"signer_priv_key" : sign_priv_key_str
		"axiom_pk_str" : axiom_pub_key_str,
		"axiom_priv_key" : axiom_priv_key_str		
	}
//
*/
async function galactic_user_starter_keys(selector) {
	//
	let pub_key_str = false
	let priv_key_str = false
	if ( (selector === undefined) || (selector === "wrapper") ) {
		// Generate a local public/private key pair WRAPPER
		let keypair = await pc_wrapper_keypair_promise()
		// ---- ---- ---- ----
		let pub_key = keypair.publicKey
		let priv_key = keypair.privateKey
		// ---- ---- ---- ----                                      // g_nonce_buffer - space to use
		let exported = await g_crypto.exportKey("jwk",pub_key);
		pub_key_str = JSON.stringify(exported)

		let priv_exported = await g_crypto.exportKey("jwk",priv_key);
		priv_key_str =  JSON.stringify(priv_exported);
	}

	let sign_pub_key_str = false
	let sign_priv_key_str = false
	if ( (selector === undefined) || (selector === "signer") ) {
		// Generate a local public/private key pair SIGNER
		let signer_pair = await pc_keypair_promise()

		let signer_pub_key = signer_pair.publicKey
		let signer_priv_key = signer_pair.privateKey

		let sign_exported = await g_crypto.exportKey("jwk",signer_pub_key);
		sign_pub_key_str = JSON.stringify(sign_exported)

		let sign_priv_exported = await g_crypto.exportKey("jwk",signer_priv_key);
		sign_priv_key_str =  JSON.stringify(sign_priv_exported);
	}

	let axiom_pub_key_str = false
	let axiom_priv_key_str = false
	if ( (selector === undefined) || (selector === "derive") ) {
		// Generate a local public/private key pair SIGNER
		let axiom_pair = await axiom_keypair_promise()

		let axiom_pub_key = axiom_pair.publicKey
		let axiom_priv_key = axiom_pair.privateKey

		let axiom_exported = await g_crypto.exportKey("jwk",axiom_pub_key);
		axiom_pub_key_str = JSON.stringify(axiom_exported)

		let axiom_priv_exported = await g_crypto.exportKey("jwk",axiom_priv_key);
		axiom_priv_key_str =  JSON.stringify(axiom_priv_exported);
	}
	
	//
	let key_info = {
		"pk_str" : pub_key_str,
		"priv_key" : priv_key_str,
		"signer_pk_str"  : sign_pub_key_str,
		"signer_priv_key" : sign_priv_key_str,
		"axiom_pk_str" : axiom_pub_key_str,
		"axiom_priv_key" : axiom_priv_key_str
	}

	if ( key_info.pk_str === false ) {
		delete key_info.pk_str
		delete key_info.priv_key
	}
	if ( key_info.signer_pk_str === false ) {
		delete key_info.signer_pk_str
		delete key_info.signer_priv_key
	}
	if ( key_info.axiom_pk_str === false ) {
		delete key_info.axiom_pk_str
		delete key_info.axiom_priv_key
	}

	return(key_info)
}




//$>>	protect_hash
/*
// protect_hash
// Parameters: 
//          -- priv_keys - structure containing private keys for signing {priv_keys.signer_priv_key}
//          -- aes_key - aes key as CryptoKey
//          -- nonce - base64url encoded uint8Array
//          -- string_to_be_signed
// wrap a hash of the biomarker -- done before server create identity operation 
// Returns: As the toString of a Uint8Array  (commad delimited entries, csv)
*/

async function protect_hash(priv_keys,aes_key,nonce,string_to_be_signed) {
	//
	try {
		let priv_signer_key = priv_keys.signer_priv_key
		let sig_txt = await key_signer(string_to_be_signed,priv_signer_key)
		let iv_nonce = from_base64_to_uint8array(nonce)
		let cipher_sig = await aes_encryptor(sig_txt,aes_key,iv_nonce)
		//
		let cipher_sig_buf = new Uint8Array(cipher_sig)
		return to_base64_from_uint8array(cipher_sig_buf)
	} catch (e) {
	  console.log(e)
	  return false
	}
	//
}


//$>>	verify_protected
/*
// verify_protected
// Parameters: 
//          -- string_that_was_signed - (just the string as is)
//			-- encrypted_sig - the signature returned by protect_hash
//          -- aes_key - aes key as CryptoKey
//			-- pub_keys - An object containing public keys {pub_keys.signer_pk_str}
//          -- nonce - base64url encoded uint8Array
//          -- string_to_be_signed
// wrap a hash of the biomarker -- done before server create identity operation 
// Returns: As the toString of a Uint8Array  (commad delimited entries, csv)
*/

async function verify_protected(string_that_was_signed,encrypted_sig,pub_keys,aes_key,nonce) {
	try {
		let signer_pk_str = pub_keys.signer_pk_str
		let iv_nonce = from_base64_to_uint8array(nonce)
		let cipher_sig = await from_base64_to_uint8array(encrypted_sig)
		let clear_sig =  await g_crypto.decrypt({
													name: "AES-CBC",
													iv  : iv_nonce
												},
												aes_key,
												cipher_sig
											);
		const decoder = new TextDecoder();
		let sig_txt = decoder.decode(clear_sig);
		//
		let verified = await verifier(string_that_was_signed,sig_txt,signer_pk_str)
		return verified
	} catch (e) {
		console.log(e)
	}
	return false
}


//$>>	gen_public_key
/*
// gen_public_key
// Parameters:
//     		-- info - an info object (javascript object) which gain fields info.public_key and info.signer_public_key
//                      optionally provides a field info.biometric, which will be signed and signature will be put into this field
//       	-- store_info - a method taking two parameters (info,privates)  privates is the Object created in this method
*/
async function gen_public_key(info,store_info) {
	let keys = await galactic_user_starter_keys()
	//
	info.public_key = keys.pk_str		// user info is the basis for creating a user cid the public key is part of it
	info.signer_public_key = keys.signer_pk_str
	info.axiom_public_key = keys.axiom_pk_str
	//
	let aes_key = await gen_cipher_key()
	let storable_key = await aes_to_str(aes_key) 
	let nonce = gen_nonce()
	//
	let privates = {		// private keys will be stored locally, and may offloadded from the browser at the user's discretion.
		'priv_key' : keys.priv_key,
		'signer_priv_key' : keys.signer_priv_key,
		'axiom_priv_key' : keys.axiom_priv_key,
		'signature_protect' : {
			"key" : storable_key,
			"nonce" : nonce
		}
	}
	info.biometric = await protect_hash(privates,aes_key,nonce,info.biometric)
	if ( store_info ) store_info(info,privates)
}

//$>>	unwrapped_aes_key
/*
//>--
// unwrapped_aes_key
// Parameters: 
//            -- wrapped_aes : as a buffer containing a jwk formatted key
//            -- unwrapper_key : as a buffer the result of importing the key
// Returns: aes_key as a CryptoKey structure (see crypto.subtle.generateKey) with encrypte and decrypt permissions
*/
async function unwrapped_aes_key(wrapped_aes,unwrapper_key) {
  let unwrapped_aes = await g_crypto.unwrapKey(
        "jwk", // same as wrapped
        wrapped_aes, //the key you want to unwrap
        unwrapper_key, //the private key with "unwrapKey" usage flag
        {   //these are the wrapping key's algorithm options
            name: "RSA-OAEP",
            modulusLength: 4096, //can be 1024, 2048, or 4096
            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
            hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
        },
        {   //this what you want the wrapped key to become (same as when wrapping)
            name: "AES-CBC",
            length: 256
        },
        true, //whether the key is extractable (i.e. can be used in exportKey)
        ["encrypt", "decrypt"] //the usages you want the unwrapped key to have
      )
  //
  return unwrapped_aes
}
//--<


//$>>	derive_aes_key
/*
//>--
// derive_aes_key
// Parameters: 
//            -- sender_pub_key_buffer : as a buffer containing a jwk formatted key
//            -- local_private : as a buffer the result of importing the key
// Returns: aes_key as a CryptoKey structure (see crypto.subtle.generateKey) with encrypte and decrypt permissions
*/
async function derive_aes_key(remote_pub_key_buffer,local_private) {
	let derived_aes = await g_crypto.deriveKey(
	  {
		name: "ECDH",
		public: remote_pub_key_buffer
	  },
	  local_private,
	  {
		name: "AES-CBC",
		length: 256
	  },
	  false,
	  ["encrypt", "decrypt"]
	);

	return derived_aes
}


//$>>	key_wrapper
/*
// key_wrapper
// Parameters:
//        -- key_to_wrap  as Cryptokey
//        -- pub_wrapper_key :  the public wrapper key (for instance a receiver key) as jwk in JSON parseable string
// Returns: the wrapped key in a string that can be sent
*/
async function key_wrapper(key_to_wrap,pub_wrapper_key) {
	try {
		let wrapper_jwk = JSON.parse(pub_wrapper_key)
		let wrapper = await g_crypto.importKey(
				"jwk",
				wrapper_jwk,
				{   //these are the wrapping key's algorithm options
					name: "RSA-OAEP",
					modulusLength: 4096, //can be 1024, 2048, or 4096
					publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
					hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
				},
				true,
				["wrapKey"]
		);

		let wrapped_key = await g_crypto.wrapKey(
											"jwk",
											key_to_wrap,
											wrapper,
											{   //these are the wrapping key's algorithm options
												name: "RSA-OAEP"
											}
										);
		let type8 = new Uint8Array(wrapped_key)
		let tranportable = to_base64_from_uint8array(type8)
		return tranportable
	} catch(e) {
		console.log(e)
	}
	return false
}


//$>>	key_unwrapper
/*
// key_unwrapper
// Parameters:
//        -- wrapped_key : as base64url encoded uint8array for passing to unwrapped_aes_key
//        -- piv_wrapper_key :  the private key (for instance a sender key) as a JSON.parseable string representing jwk
// Returns: the unwrapped key in a string that can be sent
*/
async function key_unwrapper(wrapped_key,piv_wrapper_key) {
	let wrapper_jwk = JSON.parse(piv_wrapper_key)
	let unwrapper = await g_crypto.importKey(
			"jwk",
			wrapper_jwk,
			{   //these are the wrapping key's algorithm options
				name: "RSA-OAEP",
				modulusLength: 4096, //can be 1024, 2048, or 4096
				publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
				hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
			},
			true,
			["unwrapKey"]
	);
	
	// wrapped_key
	let wrapped_aes = from_base64_to_uint8array(wrapped_key)
	let aes_key = await unwrapped_aes_key(wrapped_aes,unwrapper)
	return aes_key
}



//$>>	derive_key
/*
// derive_key
// Parameters:
//        -- sender_public_key : as base64url encoded uint8array representation of a ECDH public key with derivation privileges.
//        -- piv_axiom_key :  the private key (for instance a sender key) as a JSON.parseable string representing jwk
// Returns: the unwrapped key in a string that can be sent
*/
async function derive_key(sender_public_key,piv_axiom_key) {
	let axiom_jwk = JSON.parse(piv_axiom_key)
	let local_private = await g_crypto.importKey(
			"jwk",
			axiom_jwk,
			{   //these are the wrapping key's algorithm options
				name: "RSA-OAEP",
				modulusLength: 4096, //can be 1024, 2048, or 4096
				publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
				hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
			},
			true,
			["deriveKey"]
	);
	
	// wrapped_key
	let sender_pub_key_buffer = from_base64_to_uint8array(sender_public_key)
	let aes_key = await derive_aes_key(sender_pub_key_buffer,local_private)
	return aes_key
}



//$>>	aes_to_str
/*
// aes_to_str 
// Parameters: 
        -- aes_key - as Cryptokey
        -- transport_type :  can be "jwk" or "raw"
  Export an AES secret key given an ArrayBuffer containing the raw bytes.
// Returns: the export key JSON.stringify if 'jwk' ||  base64url Uint8Array if 'raw'
*/
async function aes_to_str(aes_key,transport_type) {
	switch ( transport_type ) {
		case "jwk" : {
			const exported = await g_crypto.exportKey("jwk", aes_key);
			let key_str = JSON.stringify(exported)
			return key_str
		}
		case "raw" :
		default: {
			const exported = await g_crypto.exportKey("raw", aes_key);
			const exportedKeyBuffer = new Uint8Array(exported);
			let key_str = to_base64_from_uint8array(exportedKeyBuffer)
			return key_str
		}
	}
}


//$>>	importAESKey
/*
// importAESKey
// Parameters:
//        -- rawKey 
//        -- transport_type :  can be "jwk" or "raw"
// Returns:  a Promise   (await this function) resolves to a CryptoKey representing the secret key
  Import an AES secret key from an ArrayBuffer containing the raw bytes.
  Takes an ArrayBuffer string containing the bytes.
*/
function importAESKey(rawKey,transport_type) {
  return g_crypto.importKey(
		transport_type,
		rawKey,
		{
			name: "AES-CBC",
			length: 256
		},
		true,
		["encrypt", "decrypt"]
  );
}


//$>>	aes_from_str
/*
// aes_from_str
// Parameters:
//        -- aes_key_str  : 	the export key JSON.stringify if 'jwk' 
//        -- transport_type :  can be "jwk" or "raw" ||  base64url Uint8Array if 'raw'
// Returns:  the aes_key Cryptokey the result of import
*/
async function aes_from_str(aes_key_str,transport_type) {
	switch ( transport_type ) {
		case "jwk" : {
			try {
				let key_obj = JSON.parse(aes_key_str)
				let key = await importAESKey(key_obj,"jwk")
				return key
			} catch (e) {}
			break;
		}
		case "raw" :
		default: {
			let buf = from_base64_to_uint8array(aes_key_str)
			let key = await importAESKey(buf,"raw")
			return key
		}
	}
}


//$>>	key_signer
/*
// key_signer
// Parameters:
//        -- data_to_sign  as a string 
//        -- priv_signer_key :  the private key (for instance a sender key) for signing 
//                              passed as a string that can be JSON.parserd into a jwk format
// Returns: the a base64url string containing the signature
*/
async function key_signer(data_to_sign,priv_signer_key) {
	try {
		let signer_jwk = JSON.parse(priv_signer_key)
		let signer = await g_crypto.importKey(
				"jwk",
				signer_jwk,
				{
					'name': "ECDSA",
					'namedCurve': "P-384"
				},
				true,
				["sign"]
		);

		let enc = new TextEncoder();
		let signable = enc.encode(data_to_sign);
		let signature = await g_crypto.sign({
												name: "ECDSA",
												hash: {name: "SHA-384"},
											},
											signer,
											signable
										);

		let type8 = new Uint8Array(signature)
		let tranportable = to_base64_from_uint8array(type8)
		return tranportable
	} catch(e) {
		console.log(e)
	}
	return false
}


//$>>	verifier
/*
// verifier
// Parameters:
//		-- was_signed_data : as a string that was originially passed to key_signer
//		-- signature : the a base64url string containing the signature
//		-- signer_pub_key :  the public key (for instance a sender key) for verification  
//                           passed as a string that can be JSON.parserd into a jwk format
// Returns: bool
*/
async function verifier(was_signed_data,signature,signer_pub_key) {
	try {
		let signer_jwk = JSON.parse(signer_pub_key)
		let verifier = await g_crypto.importKey(
				"jwk",
				signer_jwk,
				{
					'name': "ECDSA",
					'namedCurve': "P-384"
				},
				true,
				["verify"]
		);
		//
		let enc = new TextEncoder();
		let verifiable = enc.encode(was_signed_data);

		let sig_bytes = from_base64_to_uint8array(signature)

		let result = await g_crypto.verify({
											name: "ECDSA",
											hash: {name: "SHA-384"},
										},
										verifier,
										sig_bytes,
										verifiable
									);
		return result
	}  catch(e) {
		console.log(e)
	}
	return false
}

//$>>	encipher_message
/*
// encipher_message
// Parameters:
//        -- message :  a text string
//        -- aes_key :  as CryptoKey
//        -- nonce : as a string storing a buffer base64url
// Returns: a base64url encoding of the enciphered buffer
*/
async function encipher_message(message,aes_key,nonce) {
	try {
		if ( aes_key ) {
			let iv_nonce = from_base64_to_uint8array(nonce)
			let enciphered = await aes_encryptor(message,aes_key,iv_nonce)
			let b8a = new Uint8Array(enciphered)
			return to_base64_from_uint8array(b8a)
		}
	} catch(e) {
		console.log(e)
	}
	return false
}
// 


//$>>	decipher_message
/*
// decipher_message
// Parameters:
//        -- message :  as a string storing a buffer formatted as csv of the entries
//        -- wrapped_key :  wrapped aes key 
//                          passed as a string that can be JSON.parsed into a jwk format object
//        -- priv_key : the private key for unwrapping
//        -- nonce : as a string storing a buffer base64url
// Returns: The clear string or false if it cannot be decrypted
*/
async function decipher_message(message,wrapped_key,priv_key,nonce) {
	try {
		let aes_key = await key_unwrapper(wrapped_key,priv_key)
		if ( aes_key ) {
			let iv_nonce = from_base64_to_uint8array(nonce)
			let buffer = from_base64_to_uint8array(message)
			let clear = await aes_decipher_message(buffer,aes_key,iv_nonce)
			return clear
		}
	} catch(e) {
		console.log(e)
	}
	return false
}
// 


//$>>	derived_decipher_message
/*
// derived_decipher_message
// Parameters:
//        -- message :  base64url encoded string returned from encipher
//        -- remote_public : a pubic key for ECDH P-384 key encryption 
//                          passed as a string that can be JSON.parsed into a jwk format object
//        -- priv_key : the private key forming the local counterpart to the sender_public key.
//        -- nonce : as a string storing a buffer base64url
// Returns: The clear string or false if it cannot be decrypted
*/
async function derived_decipher_message(message,remote_public,priv_key,nonce) {
	try {
		let aes_key = await derive_key(remote_public,priv_key)
		if ( aes_key ) {
			let iv_nonce = from_base64_to_uint8array(nonce)
			let buffer = from_base64_to_uint8array(message)
			let clear = await aes_decipher_message(buffer,aes_key,iv_nonce)
			return clear
		}
	} catch(e) {
		console.log(e)
	}
	return false
}
//


//$EXPORTABLE::
/*
gen_nonce
gen_cipher_key
pc_keypair_promise
axiom_keypair_promise
pc_wrapper_keypair_promise
aes_encryptor
aes_decipher_message
galactic_user_starter_keys
protect_hash
verify_protected
gen_public_key
unwrapped_aes_key
derive_aes_key
key_wrapper
key_unwrapper
derive_key
aes_to_str
importAESKey
aes_from_str
key_signer
verifier
encipher_message
decipher_message
derived_decipher_message
*/



//
// MODULE: CWID (windowized)

const HASH_SEP = '!'

// >> import
//modularize>> import * as base64 from "../modules/base64.js";
//modularize>> import * as base_string from "../modules/base_string.js";
//<<


//$>>	fetch_tables
let formats = false;
let multibase = false;

async function fetch_tables() {
    try {
        formats = await fetch('../assets/formats.json')
        .then(response => response.json());
    
        multibase = await fetch('../assets/multibase.json')
            .then(response => response.json());
        return true
    } catch (e) {}
    return false
}

setTimeout(fetch_tables,0)


//$>>	do_hash_buffer
async function do_hash_buffer(text) {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hash = await g_crypto.digest('SHA-256', data);
    return hash
}

//$>>	do_hash
async function do_hash(text) {
    let buffer = await do_hash_buffer(text)
    const hashArray = Array.from(new Uint8Array(buffer));
    return base64.bytesToBase64(hashArray)
}

//$>>	to_base64
function to_base64(text) {
    return base64.base64encode(text)
}

//$>>	from_base64
function from_base64(base64text) {
    let bytesAsText = base64.base64decode(base64text)
    return bytesAsText
}


// https://docs.ipfs.io/concepts/content-addressing/
// -- https://github.com/multiformats/multicodec/blob/master/table.csv
// MULTI BASE FOR IPFS Support 
// u = no padding
// U = with padding
/*

function do_hash (text) {
    const hash = crypto.createHash('sha256');
    hash.update(text);
    let ehash = hash.digest('base64');
    ehash = ehash.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    return(ehash)
}


sha2-256	multihash	0x12	permanent	
sha2-512	multihash	0x13	permanent	
sha3-512	multihash	0x14	permanent	
sha3-384	multihash	0x15	permanent	
sha3-256	multihash	0x16	permanent	
sha3-224	multihash	0x17	permanent	

// does not start with Qm, so it is v1.

let cidV1 = 'u' +  encode( 0x55 | 0x12 |  256  encoded 256 bytes...) 


base64url - cidv1 - raw - (sha2-256 : 256 : 6E6FF7950A36187A801613426E858DCE686CD7D7E3C0FC42EE0330072D245C95)

multibase - version - multicodec - multihash (name : size : digest in hex)

*/


//$>>	CWID

const _do_hash = do_hash

class CWID {

    constructor() {
        this.version = '01'
        this.size = 256/8
        this.hash_code = formats ? formats["sha2-256"].code.substr(2) : '12'
        this.base = 'base64url'
        this.base_code = multibase ? multibase['base64url'].code : 'u'
        this.data_type = 'raw'
        this.type_code = formats ? formats[this.data_type].code.substr(2) : '55'
        this._descriptor = false
        this.tables_promised = false
        this.select_base(this.base)
    }

    correct_base(base) {
        if ( base === 'hex') return 'base16'
        else if ( base === 'oct' ) return 'base8'
        return base
    }

    async select_base(base) {
        if ( this.tables_promised !== false ) {
            await this.tables_promised
            this.tables_promised = false
        }
        if ( multibase === false ) {
            this.tables_promised = new Promise((resolve,reject) => {
                setTimeout(async () => {
                    let b = await fetch_tables()
                    resolve(b)
                },0)    
            })
        } else {
            base = this.correct_base(base)
            this.base = base
            this.base_code = multibase[base].code
            this._descriptor = false
            this.descriptor()    
        }
    }

    _descriptor_in_base() {
        if ( this.base !== 'base16' ) {
            switch ( this.base ) {
                case 'base64url': {
                    let AoB = base_string.hex_toByteArray(this._descriptor)
                    let descr = base64.bytesToBase64(AoB)
                    this._descriptor = descr.replace(/\=+/g,'')
                    break;
                }
                case 'base64' :
                default: {
                    let AoB = base_string.hex_toByteArray(this._descriptor)
                    this._descriptor = base64.bytesToBase64(AoB,true)
                    break;
                }
            }
        }
        return this._descriptor
    }

    async _hash_of_sha(text,base) {
        if ( !(base) ) base = 'base64url'
        if ( base === 'base64url' ) {
            let hh = await _do_hash(text)
            return hh.replace(/\=+/g,'')
        } else if ( base === 'hex' || base === 'base16' ) {
            let b64 = await do_hash_buffer(text)
            return base_string.hex_fromTypedArray(new Uint8Array(b64))
        } else {
            return  await _do_hash(text)
        }
    }

    descriptor() {
        if ( this._descriptor ) {
            return this._descriptor
        }
        let dstr = this.version.toString(16)
        dstr += this.type_code
        dstr += this.hash_code
        dstr += this.size.toString(16)
        this._descriptor = dstr
        dstr = this._descriptor_in_base()
        return dstr
    }

    async cwid(text) {
        let hh = await this._hash_of_sha(text,this.base)
        let code = this.descriptor()
        let _cwid = this.base_code + code + HASH_SEP + hh
        return _cwid
    }

    hash_from_cwid(cwid) {
        let parts = cwid.split(HASH_SEP)
        return(parts[1])
    }

    hash_buffer_from_cwid(cwid) {
        let base = cwid[0]
        let hh = this.hash_from_cwid(cwid)
        let ua8 = false
        if ( base === 'u' ) {
            while ( hh.length % 4 ) hh += '='
            ua8 = base64.base64ToBytes(hh)
        } else if ( base === 'f' ) {
            ua8 = base_string.hex_toByteArray(hh)
        }
        return ua8
    }


    _hex_parts_to_CWID(prefix,rest) {
        let preBuf = base_string.hex_toByteArray(prefix)
        let tailBuf = base_string.hex_toByteArray(rest)
        prefix = base64.bytesToBase64(preBuf)
        prefix = prefix.replace(/\=+/g,'')
        rest = base64.bytesToBase64(tailBuf)
        rest = rest.replace(/\=+/g,'')
        let cwid = 'u' + prefix + HASH_SEP + rest
        return cwid
    }

    _base64_parts_to_hex_CWID(prefix,rest) {
        while ( prefix.length % 4 ) prefix += '='
        while ( rest.length % 4 ) rest += '='
        let preBuf = base64.base64ToBytes(prefix)
        let tailBuf = base64.base64ToBytes(rest)
        prefix = base_string.hex_fromByteArray(preBuf)
        rest = base_string.hex_fromByteArray(tailBuf)
        let cwid = 'f' + prefix + HASH_SEP + rest
        return cwid
    }


    change_base(cwid,to) {
        let from = cwid[0]
        let code = cwid.substr(1)
        if ( from === to ) {
            return cwid
        }
        switch(from) {
            case 'f' : {
                if ( to === 'u' ) to = 'base64url'
                if ( (to !== 'base64') && (to !== 'base64url') ) {
                    console.log("only support from hex-to-base64<type>")
                    return false
                }
                let [prefix,rest] = code.split(HASH_SEP)
                return this._hex_parts_to_CWID(prefix,rest)
            }
            case 'u': {
                if ( from === 'u' ) from = 'base64url'
                if ( to === 'f' ) to = 'hex'
                if ( (to !== 'base16') && (to !== 'hex') ) {
                    console.log("only support from hex-to-base64<type>")
                    return false
                }
                let [prefix,rest] = code.split(HASH_SEP)
                return this._base64_parts_to_hex_CWID(prefix,rest)
            }
        }
        return false
    }

    async ipfs_cid(text) {
        if ( this.base === 'base16' ) {
            let _cwid = await this.cwid(text)
            _cwid = _cwid.replace(HASH_SEP,'')
            return _cwid
        } else if ( (this.base === 'base64') || (this.base === 'base64url') ) {
            let _cwid = await this.cwid(text)
            this.select_base('base64url')
            return this.cwid_to_cid(_cwid)
        } else {
            let backup_base = this.base
            this.select_base('base16')
            let _cwid = await this.cwid(text)
            _cwid = _cwid.replace(HASH_SEP,'')
            this.select_base(backup_base)
            return _cwid
        }
    }

    ipfs_cid_to_cwid(cid) {
        let code = cid[0]
        let bytes = cid.substr(1)
        let cwid = ''
        switch (code) {
            case 'f' : {
                let prefix = bytes.substr(0,8)
                let rest  = bytes.substr(8)
                cwid = 'f' + prefix + '!' + rest
                break
            }
            case 'u' : {
                let buf = base64.base64ToBytes(bytes)
                let hexstr = base_string.hex_fromByteArray(buf)
                let prefix = hexstr.substr(0,8)
                let rest  = hexstr.substr(8)
                cwid = this._hex_parts_to_CWID(prefix,rest)
                break
            }
            default : {
                return false
            }
        }
        return cwid
    }

    cwid_to_cid(cwid) {
        let parts = cwid.split(HASH_SEP)
        let p = parts[0].substr(1)
        while ( p.length % 4 ) p += '='
        parts[0] = base64.base64ToBytes(p)
        p = parts[1]
        while ( p.length % 4 ) p += '='
        parts[1] = base64.base64ToBytes(p)
        var bytes = new Uint8Array([
            ...parts[0],
            ...parts[1]
        ]);
        let cid = base64.bytesToBase64(bytes)
        cid = this.base_code + cid
        return cid
    }

}



//$EXPORTABLE::
/*
fetch_tables
do_hash_buffer
do_hash
to_base64
from_base64
CWID
*/




//
// MODULE: UCWID (windowized)

// >> import

//modularize>> import * as cwraps from './client/crypto-wraps.js';

//<<


//$>>	UCWID
class UCWID {
    //
    constructor(conf) {
        //
        this.cwid_service = new CWID()
        //
        this.key_pack = false
        this.normalizer_wait = false
        this.normalizer_promise = false
        // For non module code not relying on a server to provide lazy import (Normalized must be specified)
        if ( typeof conf.normalizer === "function" ) {
            this.normalizer = conf.normalizer(conf)
        } else {
            throw new Error("no normalizer")
        }
        // 
        if ( (conf === undefined) || (conf._wrapper_key === undefined) ) {
            this.key_wait = true
            this.key_promise = new Promise((resolve,reject) => {
                (async () => { await this.provide_keys(); this.key_wait = false; resolve(true) })()
            })
        } else {
            this.key_wait = false
            this._wrapper_key = conf._wrapper_key
        }
    }

    wait_for_normalizer() {
        return [this.normalizer_wait, this.normalizer_promise]
    }

    wait_for_key() {
        return [this.key_wait, this.key_promise]
    }

    key_package() {
        return this.key_pack
    }

    //
    async provide_keys() {
        let key_pack = await cwraps.galactic_user_starter_keys("wrapper")
        this._wrapper_key = key_pack.pk_str
        this.key_pack = key_pack
        return key_pack
    }

    set wrapper_key(wkey) {
        this._wrapper_key = wkey
    }

    get wrapper_key() {
        return this._wrapper_key
    }

    async ucwid_constructor(clear_cwid,crypto_cwid) {
        let ucwid_packet = {
            "clear_cwid" : clear_cwid,
            "crypto_cwid" : crypto_cwid
        }
        let n_version = this.normalizer.version()
        let pack_str = JSON.stringify(ucwid_packet)
        let packet_cwid = await this.cwid_service.cwid(pack_str)
        let u_cwid = n_version + '!' + packet_cwid
        return [u_cwid,ucwid_packet]     
    }

    //
    async ucwid(data) {
        //
        let normalize = false
        let buf_as_str = false 

        if ( typeof data === "string" ) {
            normalize = true
            buf_as_str = atob(data)
            data = this.normalizer.normalize(data)
        } else { //make them the same until there is a method for digital normalization...
            buf_as_str = to_base64_from_uint8array(data)
            data = buf_as_str
        }

        // clear ID
        let clear_cwid = await this.cwid_service.cwid(data)
        let c_cwid_hash = clear_cwid.split('!')[1]
console.log(c_cwid_hash)
        // crypto ID
        let nonce = cwraps.gen_nonce(c_cwid_hash)
console.log(nonce)
        let aes_key = await cwraps.gen_cipher_key()
        let cipher_text = await cwraps.encipher_message(buf_as_str,aes_key,nonce)
        let crypto_cwid = await this.cwid_service.cwid(cipher_text)
        //
        // UCWID formation
        let wrapped_key = await cwraps.key_wrapper(aes_key,this._wrapper_key)
        //
        let [u_cwid,ucwid_packet] = await this.ucwid_constructor(clear_cwid,crypto_cwid)
        //
        return { "ucwid" : u_cwid, "info" : {
                                                "ucwid_packet" : ucwid_packet,
                                                "wrapped_key" : wrapped_key,
                                                "nonce" : nonce,
                                                "cipher_text" : cipher_text,
                                                "type_original" : normalize ? "string" : "buffer"
                                            }}
    }
}




//$EXPORTABLE::
/*
UCWID
*/



// MODULE: ONE TABLE(windowized)

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

//>>  AppDBWrapper


// In the following line, you should include the prefixes of implementations you want to test.
window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
// DON'T use "var indexedDB = ..." if you're not in a function.
// Moreover, you may need references to some window.IDB* objects:
window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction || {READ_WRITE: "readwrite"}; // This line should only be needed if it is needed to support the object's constants for older browsers
window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
// (Mozilla has never prefixed these objects, so we don't need window.mozIDB*)


/*

// autoIncrement set to true  (for this special case DB use )

DB_VERSION
DATA_STORE
describe_data

*/


function warn(str) {
    //
}


// a session is a project...
// a session object (sessionObject) is stored in the DB and may contain parts of data
// part_id identifies a part of the data (e.g. a layer or a component)

class AppDBWrapper {

    constructor(name,conf) {
        this._can_process_db = true
        if ( !(window.indexedDB) ) {
            this._can_process_db = false
            console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
        }
        //
        let self = this
        // DATA_STORE
        // DB_VERSION
        // describe_data
        if ( conf ) {
            for ( let ky in conf ) {
                self[ky] = conf[ky]
            }    
        }
        //
        this.db = false
        this.current_session_name = 'none'
        this._session_name_list = []
        this.name = name
        //
    }


    set session_name(name) {
        this.current_session_name = name
    }

    get session_name() {
        return this.current_session_name
    }

    get name_list() {
        return this._session_name_list
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    init_database() {
        //
        if ( !(this._can_process_db) ) return false
        let self = this
        let db_name = this.name
        //
        let p = new Promise((resolve,reject) => {

            let request = window.indexedDB.open(db_name, this.DB_VERSION);
            //
            // <-- onerror
            request.onerror = (event) => {
                alert(`This web app will not store ${this.describe_data} without the use of computer storage.`)
            };
            
            // <-- onsuccess
            request.onsuccess = (event) => {
                //
                let db = event.target.result;
                db.onerror = (event) => {
                    console.log("Database error: " + event.target.error);
                    reject(event.target.error)
                };
                //
                self.db = db;
                resolve(db)
            }

            // <-- onupgradeneeded
            request.onupgradeneeded = (event) => {
                //
                let db = event.target.result;
                //
                try {
                    let sessionObjectStore = db.createObjectStore(this.DATA_STORE, { autoIncrement : true });
                    sessionObjectStore.createIndex("name", "name", { unique: true });
                    sessionObjectStore.createIndex("sess_date_time", "sess_date_time", { unique: true });
                } catch (e) {
                }
            //
            };
        })  // end of promise
        //
        return p
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //      load_name_list
    // -- 
    load_name_list() {
        if ( !(this.db) ) return
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readonly");
        let dataStore = transaction ? transaction.objectStore(this.DATA_STORE) : false
        //
        if ( !(dataStore) ) return false
        let p = new Promise((resolve,reject) => {
            this._session_name_list = []
            let myIndex = dataStore.index('name');
            myIndex.openCursor().onsuccess = (event) => {
                let cursor = event.target.result;
                if ( cursor ) {
                    this._session_name_list.push(cursor.value.name)
                    this.application_total_entry(cursor.value)
                    cursor.continue();
                } else {
                    this.application_update_session_name_selections(this.current_session_name,this._session_name_list)
                    resolve(true)
                }
            }
        })
        //
        return p
    }

    // _apply_find_by_name
    //  -- a generic that calls success_callback when an element matches the index, or not_found_callback otherwise.
    //
    _apply_find_by_name(sess_name, store, success_callback, not_found_callback) {
        let nameIndex = store.index('name');
        nameIndex.get(sess_name).onsuccess = (evt) => {
            let value = evt.target.result;
            if ( value ) {
                if ( success_callback ) success_callback(value,nameIndex);
            } else {
                if ( not_found_callback ) not_found_callback();
            }
        };
    }

    // _add_session_to_db
    //  -- adds the session object to the db, sets up the basic fields... 
    //
    _add_session_to_db(dataStore,application_op,part_id) {
        //
        let sessionObj = {
            'name' : this.current_session_name,
            'sess_date_time' : '' + Date.now(),
            'data' : { },
            'hashes' : { },
            'edit_order' : []
        }
        //
        if ( part_id ) sessionObj.edit_order.push(part_id)
        //
        if ( (application_op !== undefined) && (typeof application_op === 'function') ) {
            application_op(sessionObj)
        }
        let request = dataStore.add(sessionObj);
        return request
    }
  

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    // add_data -- 
    //  Parameters: blob_data -- data stored as part of the session
    //              session id could be a layer....
    add_data(blob_data,part_id) {
        if ( !(this._can_process_db) ) return false
        if ( !(this.db) ) {
          console.log(`db not initialized :: AppDBWrapper.add_data`)
          return;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        let p = new Promise((resolve,reject) => {
            let self = this
            // update_list_callback
            let update_list_callback = (value,dbIndex) => {     // if found update
                if ( !dbIndex || (typeof value === "undefined") ) {
                    resolve(false)
                    return;
                }
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        // existing session 
                        let sessionObj = cursor.value
                        //
                        let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                        // map_id = part_id
                        // store revised data
                        sessionObj.data[part_id] = blob_data
                        // make sure the structure has been set up if not already
                        if ( sessionObj.hashes[part_id] === undefined ) {
                            sessionObj.hashes[part_id] = {}
                        }
                        if ( sessionObj.hashes[part_id].op_history === undefined ) {
                            sessionObj.hashes[part_id].op_history = []
                        }
                        // record the order in which sessions (layers) have been edited
                        sessionObj.edit_order.push(part_id)
                        //
                        // update IndexedDB
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            try {
                                self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                            } catch (e) {
                                console.log(e)
                            } finally {
                                resolve(true)
                            }
                        };

                        request.onerror = (event) => {
                            resolve(false)
                        }
                        //
                    } else {
                        resolve(false)
                    }
                }
            }
            // add_new_callback
            let add_new_callback = () => {          // if not found add a new one
                //
                let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                //
                let application_op = (sessionObj) => {
                    //
                    sessionObj.data[part_id] = blob_data
                    if ( sessionObj.hashes[part_id] === undefined ) {
                        sessionObj.hashes[part_id] = {}
                    }
                    sessionObj.hashes[part_id].op_history = []
                    //
                } 
                //
                let request = self._add_session_to_db(dataStore,application_op,part_id)
                if ( request ) {
                    request.onsuccess = (event) => {
                        self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                        resolve(true)
                    };
                    request.onerror = (event) => {
                        resolve(false)
                    }
                }
                //
            }
            //
            this._apply_find_by_name(this.current_session_name, dataStore, update_list_callback, add_new_callback)    
        })
        //
        return p
    }


    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    remove_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let remove_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        delete sessionObj.data[part_id]
                        //
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            //  item has been removed
                            console.log(`deleted ${part_id}`)
                            await this.app_secure_total_session(sess_name)
                            resolve(true)
                        };
                        //
                        request.onerror = (e) => {
                            resolve(false)
                        }
                    }
                    resolve(false)
                }
            }

            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }

            this._apply_find_by_name(sess_name, dataStore, remove_from_list_callback, not_found_callback)
        })

        return p
    }
      
    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    get_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let get_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        let value =  sessionObj.data[part_id]
                        if ( value === undefined ) {
                            resolve(false)
                        } else {
                            resolve(value)
                        }
                    }
                    resolve(false)
                }
            }
        
            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }
        
            this._apply_find_by_name(sess_name, dataStore, get_from_list_callback, not_found_callback)
        })

        return p
    }
      
 
    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //  get_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //  Returns the object controlling all the data within the session.
    get_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: get_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
          //
          // get_elem_callback
          let get_elem_callback = (value,dbIndex) => {          // element.name == sess_name exists
            //
            let keyRangeValue = IDBKeyRange.only(value.name);
            //
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
              let cursor = event.target.result;
              if ( cursor ) {
                let sessionObj = cursor.value
                resolve(sessionObj)
              } else {
                reject(null)
              }
            }
          }
          //
          // not_found_callback
          let not_found_callback = () => {                       // element.name == sess_name  NOT FOUND
            reject(null)
          }
          //
          this._apply_find_by_name(sess_name, dataStore, get_elem_callback, not_found_callback)
        })
        //
        return p
    }

     
    //  delete_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //
    delete_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false

        if ( sess_name !== 'none ') {
            if ( this.db === null ) {
                console.log("db not initialized :: delete_session")
                return false;
            }
            //
            let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
            if ( !(transaction) ) return false
            let dataStore = transaction.objectStore(this.DATA_STORE);
            if ( !(dataStore) ) return false
        
            let p = new Promise((resolve,reject) => {
                // delete_from_list_callback
                let delete_from_list_callback = (value,dbIndex) => {
                    //
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    //
                    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            let request = cursor.delete();
                            request.onsuccess = () => {
                                this.current_session_name = 'none'   /// here last
                                this.load_name_list()
                                this.application_revise_current_session(this.current_session_name)
                                resolve(true)
                            };
                        }
                        resolve(false)
                    }
                }
                //
                let not_found_callback = () => {
                    warn(`The session ${sess_name} is not in the database`)
                    resolve(false)
                }
                //
                this._apply_find_by_name(sess_name, dataStore, delete_from_list_callback, not_found_callback)    
            })
            //
            return p
        }
        return false
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    application_data_update(blob_url,part_id,blob_data) {
        // implemented by derived method (override)
    }

    async app_secure_total_session(sess_name) {
         // implemented by derived method (override)
    }

    application_revise_current_session(sess_name) {
        // implemented by derived method (override)
    }

    application_update_session_name_selections(sess_name,name_list) {

    }

    application_total_entry(sess_obj) {
        
    }

}




//$EXPORTABLE::
/*
AppDBWrapper
*/



// MODULE: FILE OPS (windowized)

//$>>	get_file_from_file_element
// called in response to a file selection through the system file browser
//
function get_file_from_file_element(file_el_id) {
	let p = new Promise((resolve,reject) => {
		let file_el = document.getElementById(file_el_id)
		if ( !file_el ) reject(false)
		file_el.addEventListener('change',(ev) => {
			//
			let file = file_el.files[0]
			let mtype = file.type
			if ( ext_of_file(file.name) === 'json' ) {
				let reader = new FileReader();
				if ( mtype === 'application/json' ) {
					reader.onload = (e) => {
						resolve(e.target.result)
					};
					reader.readAsText(file);
				}
			}
			//
		})
		file_el.click()
	})
	//
	return p
}



//$>>	generic_downloader
function generic_downloader(dataStr) {
	let downloadlink = document.getElementById("identity-download-link")
	if ( !(downloadlink) ) return false
	try {
		let mime_type = dataStr.substring(dataStr.indexOf(":")+1, dataStr.indexOf(";"))
		//
		let ext = mime_type.split('/')[1]
		//
		downloadlink.setAttribute("href",     dataStr     );
		downloadlink.setAttribute("download", (`untitled.${ext}`) );
		downloadlink.click();
	} catch (e) {}
}



//$EXPORTABLE::
/*
get_file_from_file_element
generic_downloader
*/



// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// MODULE: USER DB   (windowized)
//


/*
// user_data
{
    "name_key" : name_key,
    "name": '',
    "DOB" : "",
    "place_of_origin" : "", 
    "cool_public_info" : "", 
    "business" : false, 
    "public_key" : false,
    "signer_public_key" : false,
    "biometric" : false
}
*/



function name_key_of(user_info) {
    if ( (user_info.name === undefined) || (user_info.DOB === undefined) ) {
        return false
    }
    let name_key = `${user_info.name}-${user_info.DOB}`
    return name_key
}

function value_fallback(value) {
    let vv = value ? value : ""
    return vv
}


class HumanUserDB extends AppDBWrapper {

    constructor(conf) {
        super("human-user-records",conf)
        this.current_user_name = ""
        this.current_description = ""
        this.current_file_list = []
        //
        this.current_user_object = false
        this.current_user_data = false
        //
        this.clear_identity_list_data()
    }

    async add_user(user_object) {
        this.current_session_name = user_object.name
        let part_id = "user-meta"
        //
        let blob_data = user_object
        //
        blob_data = JSON.stringify(blob_data)
        await this.add_data(blob_data,part_id)
    }

    async update_user(user_object) {
        await this.add_user(user_object)
    }

    async get_user(sel_user) {
        try {
            let user_Obj = await this.get_session(sel_user)
            if ( user_Obj ) {
                //
                this.current_user_object = user_Obj
                //
                this.current_user_name = user_Obj.name
                //
                this.current_session_name = user_Obj.name
                //
                this.current_user_info = user_Obj.user_info
                //
                this.current_user_data = user_Obj.data
                //
                this.current_file_list = []
                let data_map = user_Obj.data
                for ( let part_id in data_map ) {
                    if ( part_id !== "user-meta" ) {
                        this.current_file_list.push(JSON.parse(data_map[part_id]))
                    }
                }
                //
                return user_Obj
            }
        } catch (e) {
            console.log("get_user")
        }
    }

    get_file_details(part_id) {
        if ( !(part_id) || (part_id.length === 0) ) return ""
        if ( this.current_user_object ) {
            let user_Obj = this.current_user_object
            if ( user_Obj ) {
                let data_map = user_Obj.data
                if ( typeof data_map[part_id] === "string" ) {
                    return JSON.parse(data_map[part_id])    
                }
            }
        }
        return false
    }

    //
    async add_file(file_name,description,svg,to_layer) {
        if ( svg === undefined ) svg = ""
        if ( to_layer == undefined ) to_layer = 0
        let file_record = {
            "name" : file_name, 
            "description" : description,
            "data" : "", "ouput" : "", "svg" : svg, "layer" : to_layer }
        //
        let data = JSON.stringify(file_record)
        await this.add_data(data,file_name)
    }

    //
    async remove_file(file_name) {
        this.current_session_name = this.current_user_name
        await this.remove_data(file_name,this.current_user_name)
    }

    //
    async remove_user() {
        this.current_session_name = this.current_user_name
        await this.delete_session(this.current_user_name)
    }

    // 
    async get_file_names() {
        let sess_name = this.current_session_name
        try {
            let sess_data = await this.get_session(sess_name)
            if ( sess_data ) {
                let f_names = Object.keys(sess_data.data)
                return f_names
            }    
        } catch (e) {
            console.log("get_file_names")
        }
        return []
    }

    async get_file_entries() {
        let sess_name = this.current_session_name
        try {
            let sess_data = await this.get_session(sess_name)
            if ( sess_data ) {
                let f_names = sess_data.data.map((f_data) => JSON.parse(f_data))
                return f_names
            }
        } catch (e) {
            console.log("get_file_entries")
        }
        return []    
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    app_add_fields(sessionObj) {
        sessionObj.project_name = this.current_user_name
        sessionObj.author = this.current_author
        sessionObj.description = this.current_description
    }

    application_data_update(blob_url,part_id,blob_data) {
        // implemented by derived method (override)
    }

    async app_secure_total_session(sess_name) {
         // implemented by derived method (override)
    }

    application_revise_current_session(sess_name) {
        // implemented by derived method (override)
    }

    application_update_session_name_selections(sess_name,name_list) {

    }


    clear_identity_list_data() {
        this.identity_list = []
        this.user_list = []
    }

    application_total_entry(identity) {
        this.identity_list.push(identity)
        this.user_list.push(identity.user_info)
    }


    async get_known_users() {
        this.clear_identity_list_data()
        await g_human_user_storage.load_name_list()
        return [this.user_list,this.identity_list]
    }
    

}



//$>>	db_startup

const DB_VERSION = 1
const DATA_STORE = "human-projects"
const describe_data = "user records"

let g_human_user_storage = false
let g_human_user_storage_ref = [false]

async function db_startup() {
    //
    g_human_user_storage = new HumanUserDB({
        "DB_VERSION" : DB_VERSION,
        "DATA_STORE" : DATA_STORE,
        "describe_data" : describe_data
    })

    await g_human_user_storage.init_database()
    await g_human_user_storage.load_name_list()

    g_human_user_storage_ref[0] = g_human_user_storage
    
    return g_human_user_storage
}



//$>>	store_user
async function store_user(user_information) {
    if ( !g_human_user_storage ) return(false)
    //
    let name_key = name_key_of(user_information)
    if ( !name_key ) return(false)
    //
    let store_u_i = Object.assign({},user_information)
    //
    let storage_obj = {		// prepare a data structure to store data made by this app's ipfs gateway
        "name" : name_key,
        "user_info" : store_u_i,
        "data" : {},
        "ucwid" : user_information.ucwid,
        "stored_externally" : false
    }
    //
    await g_human_user_storage.add_user(storage_obj)
    return(true)
}



//$>>	get_known_users
async function get_known_users() {
    if ( g_human_user_storage ) {
        return await g_human_user_storage.get_known_users()
    }
    return false
}


//$>>	unstore_user
async function unstore_user(identity) {
    let name_key = identity.name
    if ( g_human_user_storage.current_user_name !== name_key ) {
        await g_human_user_storage.get_user(name_key)
    }
    await g_human_user_storage.remove_user()
}



//$>>	finalize_user_identity
// finalize_user_identity
// Once the application gets its user ucwid's, it calls finalize_user_identity 
// and this function stores the user values in the identity object in indexedDB.
//
async function finalize_user_identity(u_info,identity_files) {
    //
// "id" : ucwid with key,
// "clear_id" : ucwid without key,
// "dir_data" : user directory structure
    //
    let storage_obj = await identity_from_user(u_info)
    //
    let ucwid = value_fallback(identity_files.id)
    storage_obj.ucwid = ucwid
    storage_obj.dirs = value_fallback(value_fallback(identity_files.dir_data).dirs)
    storage_obj.files = value_fallback(value_fallback(identity_files.dir_data).files)
    storage_obj.stored_externally =  (ucwid.length > 0)
    //
    // UPDATE
    await g_human_user_storage.update_user(storage_obj)
}





//$>>	update_identity
async function update_identity(identity) {
    try {
        let u_info = identity.user_info
        let storage_obj = await identity_from_user(u_info)
        for ( let ky in storage_obj ) {
            if ( (ky == "dirs") || (ky === "files") ) {
                storage_obj[ky] = identity[ky]
            }
        }
        if ( identity.profile_image ) {
            storage_obj.profile_image = identity.profile_image
        }
        // UPDATE
        await g_human_user_storage.update_user(storage_obj)
        //
    } catch (e) {
    }
}

//$>>	restore_identity
async function restore_identity(identity) {
    try {
        await g_human_user_storage.add_user(identity)
    } catch (e) {
    }
}


//$>>	identity_from_user
async function identity_from_user(user_info) {
    let name_key = name_key_of(user_info)
    if ( !name_key ) return(false)
    //
    try {
       let identity = await g_human_user_storage.get_user(name_key)
       return identity
    } catch (e) {
    }
    return false
}



//$>>	download_identity
var downloader_url = null
async function download_identity(user_info,remove) {
    //
    let downloadlink = document.getElementById("identity-download-link")
    if ( !(downloadlink) ) return false
    try {
        //
        let identity = await identity_from_user(user_info)
        let download_str = JSON.stringify(identity,null,4)

        let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(download_str);

        let ext = ".json"
        let fname = identity.name_key

        downloadlink.setAttribute("href",     dataStr     );
        downloadlink.setAttribute("download", (fname + ext) );
        downloadlink.click();
        //
        if ( remove ) {
            await unstore_user(identity)
        }
    } catch (e) {}
}


//$>>	upload_identity
async function upload_identity() {
    let identity_str = await get_file()
    let identity = JSON.parse(identity_str)
    await restore_identity(identity)
    return identity
}



//$EXPORTABLE::
/*
db_startup
store_user
unstore_user
finalize_user_identity
update_identity
restore_identity
identity_from_user
get_known_users
*/




// SHARED CONSTANTS


// SITE PATE
//
const SITE_PAGE_TO_FRAME = "site_page_to_frame"
const SITE_PAGE_TO_BUILDER = "site_page_to_builder"
const SITE_PAGE_TO_ALL = "RELAY"
const SITE_RELATES_TO_BUILDER = "site_page_request_id"
const SITE_RELATES_TO_FRAME = "site_page_request_action"
const SITE_RELATES_TO_ALL = "site_frame_yields_news"

// FRAME PAGE
const FRAME_PAGE_TO_HOSTED_APP = "frame_page_to_hosted_app"
const FRAME_PAGE_TO_SITE = "frame_page_to_site"
const FRAME_PAGE_TO_BUILDER = "frame_page_to_builder"
const FRAME_PAGE_TO_SERVICE_WORKER = "frame_page_to_sw"
const FRAME_PAGE_RELATES_TO_SITE = "frame_page_injector"
const FRAME_PAGE_RELATES_TO_BUILDER = "frame_page_reponses"
const FRAME_PAGE_RELATES_TO_SERVICE_WORKER = "frame_page_shared_action"
const FRAME_ACTION_TO_APP = "frame_page_request_action"
const FRAME_REQUEST_SESSION = "frame_page_request_session"
const FRAME_ACTION_FROM_APP = "hosted_app_requests_action"

// APP PAGE
//
const HOSTED_APP_TO_FRAME = "hosted_app_to_frame"
const HOSTED_APP_TO_ALL = "RELAY"
const APP_RELATES_TO_FRAME = "app_in_human_context"
const APP_RELATES_TO_ALL = "app_in_frame_yields_news"

// BUILDER PAGE
//
const BUILDER_PAGE_TO_FRAME = "builder_page_to_frame"
const BUILDER_PAGE_TO_SITE = "builder_page_to_site"
const BUILDER_RELATES_TO_SITE = "builder_page_injector"
const BUILDER_ACTION_TO_FRAME = "builder_page_request_action"


// actions
const FRAME_COMPONENT_RESPOND = "respond"
const FRAME_COMPONENT_RESPONDING = "responding"
const FAME_ACTION_LOAD_APP = "load-app"
const FAME_ACTION_INSTALL = "install-id"
const FAME_ACTION_INJECT = "inject"
const FRAME_START_SESSION = "start-session"
const FRAME_HAS_SESSION = "has-session"

// categories
const FRAME_COMPONENT_SAY_ALIVE = "q-alive"
const FRAME_COMPONENT_MANAGE_ID = "m-igid"



let g_current_user_id = false
let g_current_user_name = false
let g_current_pub_identity = false


const g_message_template =  {
                                "category" : "",
                                "direction" : "",
                                "action" : "",
                                "relationship" : ""
                            }




async function intergalactic_session_going() {
    try {
        let human_public_identity = await exists_galactic_identity()
        if ( human_public_identity.session === undefined ) {
            return false
        }
        return human_public_identity
    } catch (e) {
    }
    return false
}


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----


//
function set_current_galactic_identity(public_id) {
    g_current_user_id = public_id.ucwid
    g_current_user_name = public_id.name
    g_current_pub_identity = public_id
}


async function exists_galactic_identity() {
    if ( (typeof g_human_user_storage === "undefined") || !g_human_user_storage ) { return false }
    if ( g_current_pub_identity !== false ) {
        return g_current_pub_identity
    }
    let public_id = await g_human_user_storage.get_user(name_key)
    if ( public_id ) {
        set_current_galactic_identity(public_id)
        return g_current_pub_identity
    }
    return false
}

async function add_galactic_identity(public_identity) {
    if ( (typeof g_human_user_storage === "undefined") || !g_human_user_storage ) { return false }
    g_human_user_storage.add_user(public_identity)
    return false
}

async function update_galactic_identity(public_identity) {
    if ( (typeof g_human_user_storage === "undefined") || !g_human_user_storage ) { return false }
    g_human_user_storage.update_user(public_identity)
    return false
}


function set_current_galactic_identity(descr) {
    for ( let el_id in descr ) {
        let el = descr[el_id]
        let value = el.info === "name" ? g_current_user_name : g_current_user_id
        if ( el.type === "element" ) {
            let el = document.getElementById(el_id)
            if ( el ) {
                el.innerHTML = value
            }
        } else if ( el.type === "field" ) {
            let el = document.getElementById(el_id)
            if ( el ) {
                el.value = value
            }
        }
    }
}



async function injest_identity_to_current_id(public_id) {
	await add_galactic_identity(public_id)
	set_current_galactic_identity(public_id)
	set_contact_identity()
	initLogin()
}





// ID BUILDER PAGE COM
//
// constants in shared constants
//
let g_frame_page = false
let g_site_page = false



let g_responder_tables = {
    "human_frame" : {
        "resolver" : false,
        "rejector" : false
    }
}

function alive_response(source_name) {
    if ( g_responder_tables[source_name] !== undefined ) {
        let p = new Promise((resolve,reject) => {
            g_responder_tables[source_name].resolver = (relationship,action) => {
                g_responder_tables[source_name] = {
                    "resolver" : false,
                    "rejector" : false            
                }
                resolve(true)
            }
            g_responder_tables[source_name].rejector = (relationship,action) => {
                g_responder_tables[source_name] = {
                    "resolver" : false,
                    "rejector" : false            
                }
                reject(false)
            }
        })
        return p    
    }
    return false
}

//
let human_frame_page_application_handlers = (category,action,data,relationship) => {}
let builder_app_site_command = (category,action,data) => {}
//

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// MESSAGE HANDLERS


function install_site_page_response() {
    window.addEventListener("message", (event) => {
        let page_source = event.origin
        let expected_site = normalized_launch_url("http://localhost:5111/")  // from common
        if ( page_source !== expected_site ) {
            //
            // let opener = event.source --- the site page is assumed to be the top level of the interactions
            try {
                let mobj = JSON.parse(event.data)
                let category = mobj.category
                let relationship = mobj.relationship
                let action = mobj.action
                let direction = mobj.direction
                //
                if ( direction === SITE_PAGE_TO_BUILDER ) {
                    if ( category === FRAME_COMPONENT_SAY_ALIVE ) {
                        if ( action === FRAME_COMPONENT_RESPOND ) {
                            g_site_page = event.source
                            let message = {
                                "category": FRAME_COMPONENT_SAY_ALIVE,
                                "action" : FRAME_COMPONENT_RESPONDING,
                                "data" : false
                            }
                            tell_site_page(message)
                        }
                    } else if ( relationship === SITE_RELATES_TO_BUILDER ) {
                        let data = mobj.data
                        builder_app_site_command(category,action,data)
                    }
                }
            } catch (e) {
            }    
        }
    })
}

function install_frame_page_response() {
    window.addEventListener("message", (event) => {
        // let opener = event.source --- the site page is assumed to be the top level of the interactions
        try {
            let mobj = JSON.parse(event.data)
            let category = mobj.category
            let relationship = mobj.relationship
            let action = mobj.action
            let direction = mobj.direction
            //
            if ( direction === FRAME_PAGE_TO_BUILDER ) {
                if ( category === FRAME_COMPONENT_SAY_ALIVE ) {
                    if ( action === FRAME_COMPONENT_RESPONDING ) {
                        if ( typeof g_responder_tables.human_frame.resolver === "function" ) {
                            g_responder_tables.human_frame.resolver(relationship,action)
                        }
                    }
                } else {
                    let data = mobj.data
                    human_frame_page_application_handlers(category,action,data,relationship)
                }
            }
        } catch (e) {
        }
    })
}



// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// OPENERS

let url_for_use = (frame_use) => {   // builder application determined...
    return false
}

async function open_app_page_in_human_frame(human_frame_url,frame_use) {
    let [child,uri_of_launch] = await open_cors_window(human_frame_url,("HUMAN-FRAME-" + frame_use))
    if ( child ) {
        g_frame_page = child
        g_frame_cors_uri = uri_of_launch
        let message = {
            "category": FRAME_COMPONENT_SAY_ALIVE,
            "action" : FRAME_COMPONENT_RESPONDING,
            "data" : false
        }
        let p = alive_response("human_frame")
        tell_frame_page(message)
        try {
            let ok = await p
            if ( ok ) {
                let frame_user_url = url_for_use(frame_use)
                if ( frame_user_url ) {
                    let app_message = {
                        "category": FRAME_ACTION_LOAD_APP,
                        "action" : FAME_ACTION_LOAD_APP,
                        "data" : {
                            "revise_source" : frame_user_url,
                            "use" : frame_use
                        }
                    }
                    tell_frame_page(app_message)
                }
            }
        } catch (e) {}
    }
    return [child,uri_of_launch]
}


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// MESSAGE SENDERS


function tell_site_page(message) {
    if ( !g_site_page ) return(false)
    let msg = Object.assign({},g_message_template)
    msg.direction = BUILDER_PAGE_TO_SITE
    msg.relationship = BUILDER_RELATES_TO_SITE
    msg.action = message.action
    msg.category = message.category
    msg.data = message
    let message_str = JSON.stringify(msg)
    g_site_page.postMessage(message_str,'*')
    return true
}

function tell_frame_page(message) {
    if ( !g_frame_page ) return(false)
    let msg = Object.assign({},g_message_template)
    msg.direction = BUILDER_PAGE_TO_FRAME
    msg.relationship = BUILDER_ACTION_TO_FRAME
    msg.action = message.action
    msg.category = message.category
    msg.data = message
    let message_str = JSON.stringify(msg)
    g_frame_page.postMessage(message_str,'*')
    return true
}



install_site_page_response()
install_frame_page_response()

//  === ---------------------------------------  === ---------------------------------------  === --------------------------------------- 

function set_user_title(u_name) {
	let el = document.getElementById('active-user-title')
	if ( el  && u_name && (typeof u_name === "string") ) {
		el.innerHTML = u_name
	}
}



// MODULE: USER WINDOW_APP (windowized)
//


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// ---- ---- request_human_page
// called by the window app component of the builder app (see template/scripts)
async function request_human_page(human_name,public_identity) {
    if ( human_name ) {
        if ( human_name.length ) {
            let postable = {
                "human_name" : human_name,
                "public_identity" : public_identity
            }
			//
            let srver = 'http://localhost:8989/'
            // let prot = location.protocol
            // let sp = '//' // ${prot}${sp}
            let data_stem = "intake"
			//
            try {
                let response = await postData(`${srver}/${data_stem}`,postable)
                if ( response.status === "OK" ) {
                    let human_frame_url = response.human_url
                    let [child,uri_of_launch] = await open_app_page_in_human_frame(human_frame_url,"initialize")
                    return [child,uri_of_launch]
                }    
            } catch(e) {}

        } else {
            messages("please enter a value")
        }
    }
    return false
}


async function inialize_user_resources(identity) {
	let public_component = identity.public_component
	//
	let [child_window,human_frame_url] = await request_human_page(public_component.name,public_component)
	identity.public_component.human_frame_url = human_frame_url
	// store this locally
	if ( g_human_user_storage ) await g_human_user_storage.update_user(identity.public_component)
	return [child_window,identity]
}

var g_site_source_page_opener = false
function add_site_page_opener_response() {
	window.addEventListener("message", async (ev) => {
		let mobj = ev.data
		if ( mobj && (mobj.category === "alive") ) {
			if ( mobj.direction === "id-maker-opener" ) {
				g_site_source_page_opener = ev.source
				console.log("User interaction is ready")
			}
		}
	});	
}


async function add_user_to_human_url(id_packet) {
	let message = {
		"category": FRAME_COMPONENT_MANAGE_ID,
		"action" : FAME_ACTION_INJECT,
		"data" : id_packet

	}
	tell_frame_page(message)
}


// Give the site page what it needs to open the frame window.
// The session will be negotiated by another page.
//
async function add_site_public_user(publc_info) {
	let site_pub_info = Object.assign({},publc_info)
	//
	delete site_pub_info.public_key
	delete site_pub_info.signer_public_key
	delete site_pub_info.axiom_public_key
	//
	let message = {
		"category": FRAME_COMPONENT_MANAGE_ID,
		"action" : FAME_ACTION_INJECT,
		"data" : publc_info
	}
	//
	tell_site_page(message)
}


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

function hide_thankyou_box(theBox) {
	theBox.style.visibility = "hidden"
	theBox.style.display = "none";
	theBox.style.zIndex = 0
}

function show_thankyou_box(msg) {
	let theBox = document.querySelector("#thankyou_box")
	if ( theBox ) {
		if ( msg ) {
			let mbox = document.querySelector("#thankyou_box-message")
			if ( mbox ) mbox.innerHTML = msg

		}
		theBox.style.display = "block";
		theBox.style.visibility = "visible"
		theBox.style.zIndex = 2000
	}
}

//  === ---------------------------------------  === ---------------------------------------  === --------------------------------------- 

// // // ----------------- // // // ----------------- // // // -----------------
// // // ----------------- // // // ----------------- // // // -----------------

// initial validation application is contact
g_CurContainer = null // will be initilialized within the finalizers

// EXTRA STUFF for some gracefull clicing
var the_thankyou_box = document.getElementById("thankyou_box");

// Get the <span> element that closes the modal
function setupCaptchaClose() {
	let closerList = document.getElementsByClassName("close");
	let n = closerList.length
	for ( let i = 0; i < n; i++ ) {
		let span = closerList[i]
		span.onclick = function() {
			if ( g_CurContainer ) g_CurContainer.switchCaptchaDisplay(false)
			if ( g_captaFinalResolution ) g_captaFinalResolution(3)
		}
	}
}


async function startup() {
	setup_window_crypto()
	await db_startup()
	//not_https_switch()
}


// independent floating box..


</script>